program = { declaration } EOF ;

declaration = importDecl | funcDecl | varDecl | finalDecl | statement ;

importDecl = "import", NAMESPACE, ";" ;
funcDecl = "func", IDENTIFIER, "(", [ FUNCTION_ARGS ], ")", [ ":", TYPE_ANNOTATION ], BLOCK | ("=>", expression, ";") ;
varDecl = "var", IDENTIFIER, [ ":", TYPE_ANNOTATION ], [ { ",", IDENTIFIER, [ ":", TYPE_ANNOTATION ], } ], [ "=", [ "try" ], expression, [ { ",", expression } ] ], ";" ;
finalDecl = "final", IDENTIFIER, [ ":", TYPE_ANNOTATION ], [ { ",", IDENTIFIER, [ ":", TYPE_ANNOTATION ] } ], "=", [ "try" ], expression, [ { ",", expression } ], ";" ;

statement = expressionStatement | printlnStatement | returnStatement | tryCatchStatement | throwStatement | whileStatement | forStatement ;

expressionStatement = call, [ { ",", call } ] [ "=", expression, [ { ",", expression } ] ], ";" ;
printlnStatement = "println", "(", expression, ")" ;
returnStatement = "return", [ expression ], ";" ;
tryCatchStatement = "try", "{", BLOCK, "}", "catch", [ IDENTIFIER ], BLOCK ;
ifStatement = "if", expression, BLOCK, [ { "else", "if", expression, BLOCK } ], [ "else", BLOCK ] ;
whileStatement = "while", expression, BLOCK ;
forStatement = "for", IDENTIFIER, [",", IDENTIFIER], "in", expression, BLOCK ;

expression = [ "try" ], range | UNPACK ;
range = logic_or, [ "..", logic_or, [ "by", expression ] ] ;
logic_or = logic_and, [ { "or", logic_and } ] ;
logic_and = bitwise_or, [ { "and", bitwise_or } ] ;
bitwise_or = bitwise_xor, [ { "|", bitwise_xor } ] ;
bitwise_xor = bitwise_and, [ { "^", bitwise_and } ] ;
bitwise_and = equality, [ { "&", equality } ] ;
equality = comparison, [ { ( "!=" | "==" ), comparison } ] ;
comparison = shift, [ { ( ">" | ">=" | "<" | "<=" ), shift } ] ;
shift = term, [ { ( "<<" | ">>" ), term } ] ;
term = factor, [ { ( "-" | "+" ), factor } ] ;
factor = unary, [ { ( "/" | "*" ), unary } ] ;
unary = [ ( "!" | "-" | "~" ) ], ( unary | call ) ;
call = primary [ { ("(", [ CALL_ARGS ], ")") | (".", IDENTIFIER) | ("[", expression, "]") } ] ;
primary = BOOL | NUMBER | STRING | "(", expression, ")" | TYPE | TYPEOF | LAMBDA | CAST | LIST ;

BOOL = "false" | "true" ;
FLOAT = { DIGIT }, ".", { DIGIT } ;
INT = { DIGIT } ;
NONE = "None" ;
STRING = '"', [ { all characters } ], '"' ;
TYPE = "Bool", "Float", "Int", "None", "String", "Function", "Exception", "List", "Range" ;
TYPEOF = "typeof", "(", expression, ")" ;
LAMBDA = "|", [ CAPTURE_LIST ], "|", "(", [ FUNCTION_ARGS ], ")", [ ":", TYPE_ANNOTATION ], BLOCK | ("=>", expression | statement, ";") ;
CAST = TYPE, "(", CALL_ARGS, ")" ;
LIST = "[", CALL_ARGS, "]" ;

DIGIT = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ;

CAPTURE_LIST = IDENTIFIER, [ { ",", IDENTIFIER } ], [ "," ] ;
CALL_ARGS = expression, [ { ",", expression } ], [ "," ] ;
FUNCTION_ARGS = [ "final" ], IDENTIFIER, [ ":", TYPE_ANNOTATION ], [ { ",", [ "final" ], IDENTIFIER, [ ":", TYPE_ANNOTATION ] } ], [ ",", PACK ], [ "," ] ;
BLOCK = "{", [ { declaration - funcDecl } ], "}" ;
PACK = IDENTIFIER, "..." ;
UNPACK = "...", IDENTIFIER ;
TYPE_ANNOTATION = TYPE, [ "[", TYPE, "]" ], [ "|", TYPE ] ;

NAMESPACE = IDENTIFIER, [ { "::", IDENTIFIER } ] ;
